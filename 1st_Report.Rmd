---
title: '**First Part: COVID-19 in Spain**'
subtitle: '**Advanced Regression And Prediction**'
author: '*Roberto Jes√∫s Alcaraz Molina*'
date: "09/05/2021"
output:
  pdf_document:
    latex_engine: xelatex
    number_section: true
    highlight: tango
    fig_caption: yes
    toc: true
    # toc_depth: 4
header-includes: 
- \usepackage{float}
- \usepackage{amsbsy}
- \usepackage{amsmath}
- \usepackage{graphicx}
- \usepackage{subfig}
- \usepackage{booktabs}
bibliography: references.bib
---

```{=tex}
\begin{center}
\includegraphics[width=3in]{logouc3m}
\end{center}
```
\newpage

```{r, echo = F}
# Model packages
pacman::p_load(ranger, mixOmics, plsmod)

# Packages
# devtools::install_github("stevenpawley/recipeselectors")
pacman::p_load(COVID19, tidyverse, tidymodels, rsample, recipes, parsnip, 
               yardstick, workflows, tune, patchwork, lubridate, recipeselectors,
               doParallel, tidyquant, finetune)
library(tidyverse)
# For ggplot
theme_set(theme_tq())

# spain <- covid19(country = "spain", start = "2020-01-22", end = "2021-04-11")
# spain_new_data <- covid19(country = "spain", start = "2021-04-11", end = "2021-04-25")

# saveRDS(spain, "data/spain.RDS")
# saveRDS(spain_new_data, "data/spain_new_data.RDS")
```

```{r include=FALSE}
knitr::opts_chunk$set(warning = FALSE, 
                      echo = F, 
                      message = FALSE,
                      eval = T,
                      fig.pos="H", 
                      fig.align="center",
                      fig.width=12,
                      cache=FALSE, error = TRUE)
```

# INTRODUCTION

The aim of this project is to analyze and try to predict the confirmed cases and 
deaths due to the coronavirus pandemic (COVID-19) in Spain using regression tools.
It started the 31st of January of 2020 in La Gomera (Canary Island) and continues
until now, having almost 2.5 million confirmed cases and around 67k deaths.

All the analysis of this project, from the data cleaning until the model results
will be done mainly with the `tidyverse` [@tidyverse] and `tidymodels` [@tidymodels]
packages. The first one is well known for `R` users but the second, even though 
is still in development, has enough tools for modeling and machine learning.

In the second section, we will see from where we obtained the data and how to clean
it. In the third one, we will explore our data by doing some visualizations and
we will think about how to adress the problem. In the fourth one, we will do some
feature engineering, i.e., we will modify and create some variables, divide our
training data into folds to compare our models, and many other necessary steps 
before start modeling. In the next one, we will tune our model parameters and fit
the models. Finally, in the last section, we will select the best model and say
some conclussions.

```{r}
spain <- readRDS("00_data/spain.RDS")
spain_new_data <- readRDS("00_data/spain_new_data.RDS")
```

# DATA CLEANING

The data has been taken from the R package `COVID19` [@guidotti2020]. This COVID-19
data set contain 446 observations, which are the days from the 22nd of January 2020
until the 11th of March 2021, with 36 variables divided in 5 categories: *identifiers*,
*COVID-19 variables*, *policy measures*, *geographic information* and *external keys*.

Regarding the identifiers, we will select only date. In the second group, we have
variables related with the COVID-19 such as the cumulative number of deaths, confirmed
cases, test, etc. For the moment, we will select all of them and then we will decide.
In the policy measures, we have very important variables for the development of 
the pandemic and for our study, like `workplace_closing`, `stay_home_restrictions`
or `internal_movement_restrictions`, so we must take them into account. Finally,
there are other geographical variables that could be interesting for our models.
A description of our variables can be seen below:

```{r, eval=F}
skimr::skim(spain)
```

```{r}
population <- spain$population[1]
spain <- spain %>%
  select(date, deaths, confirmed, vaccines, hosp, icu, stay_home_restrictions,
         school_closing, workplace_closing, transport_closing, gatherings_restrictions,
         internal_movement_restrictions)
spain <- spain[, -1]

spain_new_data <- spain_new_data %>%
  select(date, deaths, confirmed, vaccines, hosp, icu, stay_home_restrictions,
         school_closing, workplace_closing, transport_closing, gatherings_restrictions,
         internal_movement_restrictions)
spain_new_data <- spain_new_data[, -1]
```

| **Variable**                     | **Description**                                          |
|:---------------------------------|----------------------------------------------------------|
| `id`                             | Unique identifier.                                       |
| `date`                           | Observation date.                                        |
| `deaths`                         | Cumulative number of deaths.                             |
| `test`                           | Cumulative number of test.                               |
| `confirmed`                      | Cumulative number of confirmed cases.                    |
| `vaccines`                       | Cumulative number of doses administered (single dose).   |
| `hosp`                           | Number of hospitalized patients on date.                 |
| `icu`                            | Number of hospitalized patients in ICUs on date.         |
| `population`                     | Total population.                                        |
| `stay_home_restrictions`         | Indicates the measures of staying at home.               |
| `school_closing`                 | Indicates the measures in education.                     |
| `workplace_closing`              | Indicates the measures of the workplace.                 |
| `transport_closing`              | Indicates the measures in the public transport.          |
| `gatherings_restrictions`        | Indicates the measures of gatherings.                    |
| `internal_movement_restrictions` | Indicates the measures of the movements between regions. |


We have realized that all numerical variables have **missing values**. Some of 
them like the deaths or confirmed cases have them at the beginning, but we have
no problem with that because there were not any cases at that time, so we will 
give 0 to these values. However, there are other variables for which we have to 
think what to do with their missing values very carefully. For instance, for the
tests, there are 399 missing values out of 451 observations, so we will remove 
it because there is no much information. For the vaccines, we have 378, which we
might expect that since the first day we had vaccines was the 3rd of January of 
2021 but also, we have some of them in the weekends. For the number of hospitalized
people and the ICU people, we have again 303 NAs, but for the moment they will 
remain in the data set. How to deal with these variables that have missing values
will be seen in next sections. Finally, the variables for the measures do not have
any missing value.

```{r}
spain <- spain %>%
  mutate(
    deaths = replace(deaths, is.na(deaths), 0),
    confirmed = replace(confirmed, is.na(confirmed), 0)
  )
spain$vaccines[1:348] <- 0
```

After that, we should modify our categorical variables, since they are encoded as
integers:

- The first one, `stay_home_restrictions`, will have three categories: no measures,
require not leaving house with exceptions (e.g: exercise) and not leaving the house. 

- The next one, `school_closing` has another four categories: no measures, recommended
closing, require closing for some schools and require closing. 

- For `workplace_closing` we have no measures, recommended closing, require closing
for some sectors and require closing. 

- For `transport_closing` we have two levels: no measures and recommended closing. 

- For `gatherings_restrictions`: no measures, restrictions between 10-100 people 
and restrictions on gatherings of less than 10 people. 

- Finally, the variable `internal_movement_restrictions` has no measures, recommend
closing or require closing.

```{r}
spain <- spain %>%
  mutate(
    stay_home = factor(stay_home_restrictions, 
                       levels = c(0, 1, 2),
                       labels = c("no", "recommended", "mandatory")),
    
    school_closing = factor(school_closing, 
                            levels = c(0, 1, 2, 3),
                            labels = c("no", "recommended", "require", "mandatory")),
    
    workplace_closing = factor(workplace_closing, 
                               levels = c(0, 1, 2, 3),
                               labels = c("no", "recommended", "require", "mandatory")),
    
    transport_closing = factor(transport_closing, 
                               levels = c(0, 1),
                               labels = c("no", "recommended")),
    
    gatherings_restrictions = factor(gatherings_restrictions, 
                                     levels = c(0, 1, 2, 3, 4),
                                     labels = c("no", "no", "no", "10-100", "<10")),
    
    internal_movement_restrictions = factor(internal_movement_restrictions, 
                                            levels = c(0, 1, 2),
                                            labels = c("no", "recommended", "mandatory")),
  ) %>%
  select(-stay_home_restrictions)

spain_new_data <- spain_new_data %>%
  mutate(
    stay_home = factor(stay_home_restrictions, 
                       levels = c(0, 1, 2),
                       labels = c("no", "recommended", "mandatory")),
    
    school_closing = factor(school_closing, 
                            levels = c(0, 1, 2, 3),
                            labels = c("no", "recommended", "require", "mandatory")),
    
    workplace_closing = factor(workplace_closing, 
                               levels = c(0, 1, 2, 3),
                               labels = c("no", "recommended", "require", "mandatory")),
    
    transport_closing = factor(transport_closing, 
                               levels = c(0, 1),
                               labels = c("no", "recommended")),
    
    gatherings_restrictions = factor(gatherings_restrictions, 
                                     levels = c(0, 1, 2, 3, 4),
                                     labels = c("no", "no", "no", "10-100", "<10")),
    
    internal_movement_restrictions = factor(internal_movement_restrictions, 
                                            levels = c(0, 1, 2),
                                            labels = c("no", "recommended", "mandatory")),
  ) %>%
  select(-stay_home_restrictions)
```

After these changes, in the next section we will perform some visualizations to 
know the distributions of the variables, relationship between them, etc.


# EXPLORATORY DATA ANALYSIS (EDA)

Our two main variables of interest are cumulative `deaths` and `confirmed` cases.
First of all, let's see how they are distributed.

```{r, fig.cap="Cumulative deaths and confirmed cases in Spain"}
p1 <- spain %>%
  ggplot(aes(x = date, y = deaths)) +
  geom_line()

p2 <- spain %>%
  ggplot(aes(x = date, y = confirmed)) +
  geom_line()

p1 + p2 
```

As we can observe, there are some mistakes in the data: in the cumulative deaths,
there is a drop around June, and in the cumulative confirmed cases, there is another
drop in February, which do not make any sense since we are considering **cumulative**
cases. Therefore, to fix that error, for all days that has a lower value than their
previous day, we will assign the value of their previous day to that day.

```{r}
for (i in 1:(nrow(spain)-1)){
  if (spain$deaths[i+1] < spain$deaths[i]) spain$deaths[i+1] <- spain$deaths[i]
  if (spain$confirmed[i+1] < spain$confirmed[i]) spain$confirmed[i+1] <- spain$confirmed[i]
}
```

```{r, fig.cap="Cumulative deaths and confirmed cases fixed"}
p1 <- spain %>%
  ggplot(aes(x = date, y = deaths)) +
  geom_line()

p2 <- spain %>%
  ggplot(aes(x = date, y = confirmed)) +
  geom_line()

p1 + p2 
```

Now let's focus on the vaccines administered and the hospitalized people:

```{r}
p1 <- spain %>%
  ggplot(aes(x = date, y = vaccines)) +
  geom_line(na.rm = T)

p2 <- spain %>%
  ggplot(aes(x = date, y = hosp)) +
  geom_line(na.rm = T)

p3 <- spain %>%
  ggplot(aes(x = date, y = icu)) +
  geom_line(na.rm = T)

p1 + p2 + p3
```

Due to the missing values, we have discontinuous plots. For `vaccines`, these missing
values appear because there are some places in Spain where the vaccination is stopped
on weekends, or because these data is not recorded on weekends. Hence, as we have
done before for the deaths and confirmed cases, we will take the value from the
day before. However, for the other two variables, there is no information prior 
to July, so we will not take them into account because it is not realistic.

```{r}
for (i in 1:nrow(spain)-1){
  if (is.na(spain$vaccines[i+1])) spain$vaccines[i+1] <- spain$vaccines[i]
}

spain <- spain %>%
  select(-hosp, -icu)

spain_new_data$vaccines[1] <- 10784997 # we take the data from the previous day
for (i in 1:nrow(spain_new_data)-1){
  if (is.na(spain_new_data$vaccines[i+1])) spain_new_data$vaccines[i+1] <- spain_new_data$vaccines[i]
}

spain_new_data <- spain_new_data %>%
  select(-hosp, -icu)
```

Then, we are going to see the relationships between our target variables, deaths
and confirmed cases, and some of the categorical predictors. Below, we can see how
predictors like `stay_home`, `workplace_closing`, `gatherings_restrictions` and `internal_movement_restrictions` are related with the confirmed cases:

```{r}
p1 <- spain %>%
  ggplot(aes(x = date, y = confirmed, color = stay_home)) +
  labs(y = " ", x = "") +
  ggtitle("Confirmed cases") +
  theme(
    legend.title = element_text(size = 10), legend.text = element_text(size = 8)
    ) + 
  geom_point()

p2 <- spain %>%
  ggplot(aes(x = date, y = confirmed, color = workplace_closing)) +
  labs(y = " ") +
  theme(
    legend.title = element_text(size = 10), legend.text = element_text(size = 8)
    ) + 
  geom_point()

p3 <- spain %>%
  ggplot(aes(x = date, y = confirmed, color = gatherings_restrictions)) +
  labs(y = " ", x = "") +
  theme(
    legend.title = element_text(size = 10), legend.text = element_text(size = 8)
    ) + 
  geom_point()

p4 <- spain %>%
  ggplot(aes(x = date, y = confirmed, color = internal_movement_restrictions)) +
  labs(y = " ") +
  theme(
    legend.title = element_text(size = 10), legend.text = element_text(size = 8)
    ) + 
  geom_point()

(p1 / p2) | (p3 / p4)
```

The first plot in the top left corner shows us that the variable `stay_home` is 
wrongly collected, since it was not mandatory to stay at home after the summer, 
so we must change it. Also, we can observe how after the summer the measures were
much more restrictives than during the summer because of the increment of new cases.
For the cummulative deaths, we can see it below: 

```{r}
spain$stay_home[278:nrow(spain)] <- "recommended"
spain_new_data$stay_home <- "recommended"
```


```{r}
p1 <- spain %>%
  ggplot(aes(x = date, y = deaths, color = stay_home)) +
  labs(y = " ", x = "") +
  ggtitle("Deaths") +
  theme(
    legend.title = element_text(size = 10), legend.text = element_text(size = 8)
    ) + 
  geom_point()

p2 <- spain %>%
  ggplot(aes(x = date, y = deaths, color = workplace_closing)) +
  labs(y = " ") +
  theme(
    legend.title = element_text(size = 10), legend.text = element_text(size = 8)
    ) + 
  geom_point()

p3 <- spain %>%
  ggplot(aes(x = date, y = deaths, color = gatherings_restrictions)) +
  labs(y = " ", x = "") +
  theme(
    legend.title = element_text(size = 10), legend.text = element_text(size = 8)
    ) + 
  geom_point()

p4 <- spain %>%
  ggplot(aes(x = date, y = deaths, color = internal_movement_restrictions)) +
  labs(y = " ") +
  theme(
    legend.title = element_text(size = 10), legend.text = element_text(size = 8)
    ) + 
  geom_point()

(p1 / p2) | (p3 / p4)
```

Again, after summer the measures become more agressive due to the new cases. In 
the following section, we will see how to modify some variables after we have more
knowledge about them.



# FEATURE ENGINEERING


In this section, based on the previous analysis of the variables, we should decide
which changes should be done in our data. Firslty, since our variables of interest,
deaths and confirmed cases, are cumulative and daily, we will aggregate them to 
have the **number of deaths and confirmed cases by week**. This decision has been
taken because there are too much noise in daily data due to different human errors
that appear when this data is collected, so taking the data weekly allow us to 
predict in a better way the future.

On the one hand, to obtain the number of deaths, confirmed cases and vaccines per
week, we will compute firstly the daily cases, substracting today's cases minus 
tomorrow's, and then we will add all the cases of the week. On the other hand, for
the categorical variables, we will compute the mode of the variables in every week,
i.e., we will give the most frequent values to every week. Below, we can our new
data set:

```{r}
calculate_mode <- function(x) {
  uniqx <- unique(x)
  uniqx[which.max(tabulate(match(x, uniqx)))]
}

spain <- spain %>%
  mutate(
    new_date = as.Date(cut(date, "week")),
    deaths_day = spain$deaths - lag(spain$deaths),
    confirmed_day = spain$confirmed - lag(spain$confirmed),
    vaccines_day = spain$vaccines - lag(spain$vaccines)
  ) %>%
  group_by(date) %>%
  summarise(
    new_date = new_date,
    date = date,
    deaths_week = sum(deaths_day),
    confirmed_week = sum(confirmed_day),
    vaccines_week = sum(vaccines_day),
    school_closing = calculate_mode(school_closing),
    workplace_closing = calculate_mode(workplace_closing),
    gatherings_restrictions = calculate_mode(gatherings_restrictions),
    stay_home = calculate_mode(stay_home),
    internal_movement_restrictions = calculate_mode(internal_movement_restrictions)
  ) %>%
  ungroup() %>%
  filter(date %in% new_date) %>%
  select(-new_date)


spain_new_data <- spain_new_data %>%
  mutate(
    new_date = as.Date(cut(date, "week")),
    deaths_day = spain_new_data$deaths - lag(spain_new_data$deaths),
    confirmed_day = spain_new_data$confirmed - lag(spain_new_data$confirmed),
    vaccines_day = spain_new_data$vaccines - lag(spain_new_data$vaccines)
  ) %>%
  group_by(date) %>%
  summarise(
    new_date = new_date,
    date = date,
    deaths_week = sum(deaths_day),
    confirmed_week = sum(confirmed_day),
    vaccines_week = sum(vaccines_day),
    school_closing = calculate_mode(school_closing),
    workplace_closing = calculate_mode(workplace_closing),
    gatherings_restrictions = calculate_mode(gatherings_restrictions),
    stay_home = calculate_mode(stay_home),
    internal_movement_restrictions = calculate_mode(internal_movement_restrictions)
  ) %>%
  ungroup() %>%
  filter(date %in% new_date) %>%
  select(-new_date)
```

```{r}
knitr::kable(head(spain))
```

Now that we have prepared our data, we have to think about what **preprocessing**
steps should we do. These are some changes that we have to apply to our data before
we start fitting the models. Our preprocessing steps will be:

1. Divide the date in month and year and convert it to categorical, because they
could be very important for the outcomes.

```{r}
spain <- spain %>%
  mutate(
    month = factor(month(date)),
    year = factor(year(date))
  )

spain_new_data <- spain_new_data %>%
  mutate(
    month = factor(month(date)),
    year = factor(year(date))
  )
```

2. Since we want to predict the deaths and confirmed cases in the following weeks,
we should take into account how many deaths and confirmed cases were the weeks 
before. Therefore, we will create some new variables which will be the deaths and
confirmed cases 3 weeks lagged, i.e., we will consider in our model what happened
in the previous weeks to be able to predict in a better way the next month.

```{r}
spain <- spain %>%
  mutate(
    lag_3_deaths_week = lag(deaths_week, n = 3),
    lag_3_confirmed_week = lag(confirmed_week, n = 3)
  ) %>%
  drop_na()

spain_new_data <- spain_new_data %>%
  mutate(
    lag_3_deaths_week = tail(spain$deaths_week, 3)[1:2],
    lag_3_confirmed_week = tail(spain$confirmed_week, 3)[1:2]
  )
```

3. Before starting fitting models, we should take a look to our predictors. We have
12 covariates which the majority of them are categorical, so we must do **feature selection**.
To do that, we will use the package `recipeselectors` [@recipeselector], which adds
some feature selection methods to the `recipes` package (from `tidymodels`) such
as variable importance or boluta methods. This time we will use recursive feature
elimination, selecting the features that are above the 20% of importance using a
random forest model. For the model that predicts the deaths per week, it removes
the variables `stay_home` and `gathering_restrictions`, nonetheless, for the confirmed
cases, it removes `workplace_closing` and again `gathering_restrictions`.

```{r}
rfe_model <- rand_forest() %>%
  set_engine("ranger", importance = "permutation") %>%
  set_mode("regression")

# Predictive model for the deaths
set.seed(1234)
select_rec_deaths <- 
  recipe(deaths_week ~ ., data = spain) %>%
  step_rm(date) %>%
  step_select_vip(all_predictors(), outcome = "deaths_week", model = rfe_model, threshold = 0.2)

spain_deaths <- select_rec_deaths %>% prep() %>% juice()
spain_deaths <- spain_deaths %>%
  mutate(date = spain$date)

# Predictive model for the confirmed cases
select_rec_confirmed <- 
  recipe(confirmed_week ~ ., data = spain) %>%
  step_rm(date) %>%
  step_select_vip(all_predictors(), outcome = "confirmed_week", model = rfe_model, threshold = 0.2)


spain_confirmed <- select_rec_confirmed %>% prep() %>% juice()
spain_confirmed <- spain_confirmed%>%
  mutate(date = spain$date)

# head(select_rec %>% prep() %>% juice())
```


4. Even though we will **test** our data with the next 3 weeks, we should divide
our training data into folds to tune the model parameters and to compare them. To
do that, there is a function called `rolling_origin` from the `rsample` package
(from `tidymodels`) which can divide our training set into different folds by date,
which is very useful for time series models. We will get 10 folds where the analysis
set will be the first 12 weeks, and the assessment set, the following 3. This method
will allow us to tune the different parameters of our models and get the best with
the lowest prediction error. After selecting the two best ones, we will again fit
the models in all our training set and then, we will see how it works in our test
set.

```{r}
set.seed(123)
spain_rolling_deaths <- rolling_origin(
  spain_deaths, 
  initial = 12, # number of weeks used to train in each resample
  assess = 3, # number of weeks used to validate in each resample
  cumulative = F,
  skip = 4
  )

spain_rolling_confirmed <- rolling_origin(
  spain_confirmed, 
  initial = 12, # number of weeks used to train in each resample
  assess = 3, # number of weeks used to validate in each resample
  cumulative = F,
  skip = 4
  )

# analysis(spain_rolling$splits[[1]])
# assessment(spain_rolling$splits[[1]])
```

5. Finally, it is time to use the `recipes` package [@recipes] to do the preprocessing
steps that the models need. For the linear regression models,

```{r}
# Recipes
basic_rec <- 
  recipe(deaths_week ~ ., data = spain) %>%
  step_rm(date) # we remove the variable date

linear_reg_rec <- 
  basic_rec %>%
  step_nzv(all_numeric_predictors(), freq_cut = 85/5) %>% # remove the zero variance variables
  step_corr(all_numeric_predictors(), threshold = 0.65) %>% # decorrelate predictors
  step_dummy(all_nominal_predictors()) # get dummy variables
  
pls_rec <- 
  basic_rec %>%
  step_nzv(all_numeric_predictors(), freq_cut = 85/5) %>% # remove the zero variance variables 
  step_normalize(all_numeric_predictors()) %>% # center and scale
  step_dummy(all_nominal_predictors()) # get dummy variables
```

# MODEL TUNING

```{r}
# Models
lm_model <- 
  linear_reg() %>%
  set_engine("lm")
  
ridge_model <- 
  linear_reg(penalty = tune(), mixture = 0) %>%
  set_engine("glmnet") %>%
  set_mode("regression")

lasso_model <- 
  linear_reg(penalty = tune(), mixture = 1) %>%
  set_engine("glmnet") %>%
  set_mode("regression")

elastic_net_model <- 
  linear_reg(penalty = tune(), mixture = tune()) %>%
  set_engine("glmnet") %>%
  set_mode("regression")

pls_model <-
  pls(predictor_prop = tune(), num_comp = tune()) %>%
  set_engine('mixOmics') %>%
  set_mode('regression')
```


```{r}
workflow_tune_compare <- workflow_set(
  preproc = list(
    linear_reg = linear_reg_rec,
    pls        = pls_rec
  ),
  models = list(
    lm_wf            = lm_model,
    ridge_wf         = ridge_model,
    lasso_wf         = lasso_model,
    elastic_net_wf   = elastic_net_model,
    model_wf         = pls_model
  ), 
  cross = T
)

workflow_tune_compare <- workflow_tune_compare %>%
  filter(wflow_id == c("linear_reg_lm_wf", "linear_reg_ridge_wf", "linear_reg_lasso_wf", "linear_reg_elastic_net_wf", "pls_model_wf"))
```

```{r, eval=F}
cl <- makePSOCKcluster(8)
registerDoParallel(cl)

grid_ctrl <-
   control_grid(
      save_pred = TRUE,
      save_workflow = TRUE
   )

workflow_results <- workflow_tune_compare %>%
  workflow_map(
    seed = 1503,
    resamples = spain_rolling,
    grid = 25,
    control = grid_ctrl,
    verbose = T
   )

# i	No tuning parameters. `fit_resamples()` will be attempted
# i 1 of 5 resampling: linear_reg_lm
# v 1 of 5 resampling: linear_reg_lm (10.7s)
# i 2 of 5 tuning:     linear_reg_ridge
# v 2 of 5 tuning:     linear_reg_ridge (3.3s)
# i 3 of 5 tuning:     linear_reg_lasso
# v 3 of 5 tuning:     linear_reg_lasso (2.8s)
# i 4 of 5 tuning:     linear_reg_elastic_net
# v 4 of 5 tuning:     linear_reg_elastic_net (57.6s)
# i 5 of 5 tuning:     pls_pls
# v 5 of 5 tuning:     pls_pls (59s)

stopCluster(cl)

# saveRDS(workflow_results, "workflow_results.RDS")
```

```{r}
workflow_results <- readRDS("workflow_results.RDS")

workflow_results %>%
  pull_workflow_set_result("linear_reg_ridge_wf") %>%
  select_best()

autoplot(workflow_results, select_best = T) +
  scale_color_tq() +
  theme_tq()
```



```{r}
best_results <- 
   workflow_results %>% 
   pull_workflow_set_result("pls_model_wf") %>% 
   select_best(metric = "rmse")
best_results

best_workflow <- 
   workflow_results %>% 
   pull_workflow("pls_model_wf") %>% 
   finalize_workflow(best_results)
```

```{r}
linear_reg_ridge_res <- 
   workflow_results %>% 
   pull_workflow_set_result("linear_reg_ridge_wf") %>% 
   select_best(metric = "rmse")

linear_reg_ridge_wf <- 
   workflow_results %>% 
   pull_workflow("linear_reg_ridge_wf") %>% 
   finalize_workflow(linear_reg_ridge_res)

linear_reg_ridge_fit <- linear_reg_ridge_wf %>%
  fit(spain)

linear_reg_ridge_fit %>%
  pull_workflow_fit()

plot(linear_reg_ridge_fit$fit$fit$fit)
```


```{r, results='hide'}
# Fit the model
best_fit <- best_workflow %>%
  fit(data = spain)

best_fit$fit$fit$fit$names
best_fit %>%
  pull_workflow_fit()
plotVar(best_fit$fit$fit$fit)

# Predictions in the training and testing sets
pred_train <- best_fit %>%
  predict(new_data = spain)

pred_test <- best_fit %>%
  predict(new_data = spain_new_data)

spain %>%
  mutate(predictions = pred_train$.pred) %>%
  select(date, deaths_week, predictions) %>%
  pivot_longer(cols = c("deaths_week", "predictions"), values_to = "value")

pred_new_data <- spain_new_data %>%
  mutate(predictions = pred_test$.pred) %>%
  select(date, deaths_week, predictions) 
  
spain %>%
  mutate(predictions = pred_train$.pred) %>%
  select(date, deaths_week, predictions) %>%
  pivot_longer(cols = c("deaths_week", "predictions"), values_to = "value") %>%
  ggplot(aes(x = date, y = value)) +
  geom_line(aes(color = name), size = 1) +
  scale_color_manual(values = c("darkred", "steelblue")) +
  labs(
    y = "Deaths per week",
    x = "Date"
  ) 
```

# MODEL SELECTION AND CONCLUSIONS 


# REFERENCES
